<script>
  import { Icon, Badge, Alert, ErrorAlert, Checkbox, LoadingSpinner } from '$lib'
</script>

## Writing tests

We use vitest for unit tests and playwright for integration tests. Both of these
are located next to the source files they test.
Vitest files end with `.test.ts` and Playwright files end with `.spec.ts`.

For example the Playwright test for testing `src/routes/search/+page.svelte`
is located at `src/routes/search/page.spec.ts`.

Locally you can run the tests with

```sh
pnpm vitest # Run vitest tests
pnpm test # Run playwright tests
```

You can also run playwright tests against a running vite dev server. This is
useful for debugging tests.

```sh
# In one terminal
pnpm dev
```

```sh
# In another terminal
pnpm test:dev
```

In CI, we run vitest and playwright via the `BUILD.bazel` file. You can run e2e tests locally with

```sh
sg bazel test //client/web-sveltekit:e2e_tests
```

### Updating Playwright

The Playwright version is defined in the `package.json` of this package. The browser versions are defined in `dev/tool_deps.bzl`.

You may have to find the right combination for both tools to work nicely with each other. The easiest is to start with updating
Playwright, pushing it to CI, and seeing what happens. We will first upgrade
Playwright and install the new browsers, and then update `dev/tool_deps.bzl` based on the newly installed browsers.

**1. Upgrade Playwright**

To [update Playwright](https://playwright.dev/docs/intro#updating-playwright), navigate to `clients/web-sveltekit` and
run `pnpm add @playwright/test@latest playwright@latest` followed by `pnpm exec playwright install --with-deps`.

**2. Update Bazel**

The `install` command from above may have downloaded new browsers. You may see a log message like (on macOS) `Chromium 128.0.6613.18 (playwright build v1129) downloaded to /Users/your-user/Library/Caches/ms-playwright/chromium-1129`.

If you don't have the logs anymore, you can run `pnpm exec playwright install --dry-run` to get an overview.

If your latest browser version is newer than what's listed in `dev/tool_deps.bzl`, you'll need to update `dev/tool_deps.bzl` to
include the new browser version and the zip file's sha integrity. You can calculate it yourself, e.g. using `openssl`:

```
openssl dgst -binary -sha256 <file> | openssl base64 -A
```

or run e.g. `bazel test //client/web-sveltekit:e2e_test` to see the new integrity sha. Example below:

```
Error in download_and_extract: java.io.IOException: Error downloading [https://playwright.azureedge.net/builds/chromium/1129/chromium-mac-arm64.zip] to /private/var/tmp/_bazel_michael/680fb57cd51801cfe03bf19f9d7a0d3e/external/chromium-darwin-arm64/temp15834460500730224298/chromium-mac-arm64.zip: Checksum was sha256-WdF50K2a15LlHbga7y17zBZOb130NMCBiI+760VovQ4= but wanted sha256-5wj+iZyUU7WSAyA8Unriu9swRag3JyAxUUgGgVM+fTw=
```

## Components

### Icons

We use [unplugin-icons](https://github.com/unplugin/unplugin-icons) together
with [unplugin-auto-import](https://github.com/unplugin/unplugin-auto-import)
to manage icons. This allows us to use icons from multiple icon sets without
having to import them manually.

For a list of currently available icon sets see the `@iconify-json/*` packages
in the `package.json` file.

Icon references have the form `I<IconSetName><IconName>`. For example the
[corner down left arrow from Lucide](https://lucide.dev/icons/corner-down-left)
can be referenced as `ILucideCornerDownLeft`.

The icon reference is then used in the `Icon` component. Note that the icon
doesn't have to be imported manually.

```svelte
<script lang="ts">
  import { Icon } from '$lib'
</script>

<Icon icon={ILucideCornerDownLeft} />
```

When the development server is running, the icon will be automatically added to
`auto-imports.d.ts` so TypeScript knows about it.

### Badges

<style>
  /* Sourcegraph's color system for badges - direct hex values */
  :global(.badge) {
    display: inline-block;
    padding: 0.125rem 0.375rem;
    font-size: 0.75rem;
    font-weight: 500;
    text-align: center;
    white-space: nowrap;
    vertical-align: baseline;
    border-radius: 4px;
    line-height: 1rem;
  }
  
  :global(.primary) {
    background-color: #0b70db !important;
    color: white !important;
  }
  
  :global(.secondary) {
    background-color: #e6ebf2 !important;
    color: #343a4d !important;
  }
  
  :global(.success) {
    background-color: #2ea043 !important;
    color: white !important;
  }
  
  :global(.danger) {
    background-color: #dc3545 !important;
    color: white !important;
  }
  
  :global(.warning) {
    background-color: #ffc107 !important;
    color: black !important;
  }
  
  :global(.info) {
    background-color: #72dbe8 !important;
    color: black !important;
  }
  
  :global(.merged) {
    background-color: #a305e1 !important;
    color: white !important;
  }
  
  :global(.outline-secondary) {
    background-color: transparent !important;
    color: #5e6e8c !important;
    border: 1px solid #e6ebf2 !important;
  }
  
  :global(.link) {
    background-color: #f9fafb !important;
    color: #0b70db !important;
    font-family: monospace !important;
    font-weight: normal !important;
  }
  
  :global(.small) {
    font-size: 0.75rem !important;
    padding: 0 0.25rem !important;
    border-radius: 2px !important;
  }
  
  :global(.pill) {
    padding-right: 0.6em !important;
    padding-left: 0.6em !important;
    border-radius: 10rem !important;
  }
  
  /* Alert styles */
  :global(.alert-container [role="alert"]) {
    margin-bottom: 1rem;
    border-radius: 4px !important;
    overflow: auto;
    position: relative;
    padding: 0.5rem !important;
  }
  
  :global(.alert-container .danger) {
    border-color: #dc3545 !important;
    background-color: rgba(220, 53, 69, 0.1) !important;
  }
  
  :global(.alert-container .info) {
    border-color: #0b70db !important;
    background-color: rgba(11, 112, 219, 0.1) !important;
  }
  
  :global(.alert-container .warning) {
    border-color: #ffc107 !important;
    background-color: rgba(255, 193, 7, 0.1) !important;
  }
  
  :global(.alert-container .success) {
    border-color: #2ea043 !important;
    background-color: rgba(46, 160, 67, 0.1) !important;
  }
  
  :global(.alert-container .slim) {
    padding: 0.25rem 0.5rem !important;
  }
  
  /* Checkbox examples styles */
  :global(.checkbox-examples) {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    margin-bottom: 1rem;
  }
  
  :global(.checkbox-examples .checkbox-row) {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  
  :global(.checkbox-examples label) {
    cursor: pointer;
    user-select: none;
  }
</style>

Badges are compact visual indicators used to highlight statuses, counts, or categorize items.
They're ideal for drawing attention to important information or providing contextual labels.

#### Badge Variants

<div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 1rem;">
  <Badge>Default</Badge>
  <Badge variant="primary">primary</Badge>
  <Badge variant="secondary">secondary</Badge>
  <Badge variant="success">success</Badge>
  <Badge variant="danger">danger</Badge>
  <Badge variant="warning">warning</Badge>
  <Badge variant="info">info</Badge>
  <Badge variant="merged">merged</Badge>
  <Badge variant="outlineSecondary">outlineSecondary</Badge>
  <Badge variant="link">link</Badge>
</div>

#### Sizes and Styles

<div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-bottom: 1rem;">
  <Badge variant="primary">Standard</Badge>
  <Badge variant="primary" small>Small</Badge>
  <Badge variant="primary" pill>Pill</Badge>
  <Badge variant="success" small pill>Small Pill</Badge>
</div>

The Badge component supports various variants, sizes, and styling options:

```svelte
<script lang="ts">
  import { Badge } from '$lib'
</script>

<!-- Basic usage -->
<Badge>Default</Badge>

<!-- Variants -->
<Badge variant="primary">primary</Badge>
<Badge variant="secondary">secondary</Badge>
<Badge variant="success">success</Badge>
<Badge variant="danger">danger</Badge>
<Badge variant="warning">warning</Badge>
<Badge variant="info">info</Badge>
<Badge variant="merged">merged</Badge>
<Badge variant="outlineSecondary">outlineSecondary</Badge>
<Badge variant="link">link</Badge>

<!-- Sizes -->
<Badge variant="primary">Standard</Badge>
<Badge variant="primary" small>Small</Badge>

<!-- Pill style -->
<Badge variant="primary" pill>Pill</Badge>
<Badge variant="success" small pill>Small Pill</Badge>
```

For detailed examples and API documentation, visit the [Badge component page](/components/badge).

### Alerts

<div class="alert-container">
  Alerts display important messages to users. Use them to communicate status, provide feedback, or highlight important information.

  #### Alert Variants

  <Alert variant="info">This is an info alert with important information.</Alert>
  <Alert variant="warning">This is a warning alert that requires attention.</Alert>
  <Alert variant="danger">This is a danger alert about a critical issue.</Alert>
  <Alert variant="success">This is a success alert confirming a completed action.</Alert>

  #### Alert Sizes

  <Alert variant="info">Normal-sized alert with default padding</Alert>
  <Alert variant="info" size="slim">Slim alert with reduced padding</Alert>
</div>

```svelte
<script>
  import { Alert } from '$lib'
</script>

<!-- Alert variants -->
<Alert variant="info">Info alert</Alert>
<Alert variant="warning">Warning alert</Alert>
<Alert variant="danger">Danger alert</Alert>
<Alert variant="success">Success alert</Alert>

<!-- Alert sizes -->
<Alert variant="info">Normal size</Alert>
<Alert variant="info" size="slim">Slim size</Alert>

<!-- Custom styling -->
<Alert 
  variant="info" 
  styleOverrides={{
    backgroundColor: '#f0f8ff',
    textColor: '#003366',
    textCentered: true
  }}
>
  Custom styled alert
</Alert>
```

For detailed examples and API documentation, visit the [Alert component page](/components/alert).

### Error Alerts

<div class="alert-container">
  <ErrorAlert error="This is a simple error message" />
  <ErrorAlert title="Operation Failed" error="Unable to process your request due to a system error." />
</div>

ErrorAlert is a specialized alert component designed for displaying error messages. It works with various error types, including GraphQL errors.

```svelte
<script>
  import { ErrorAlert } from '$lib'
</script>

<!-- Basic usage -->
<ErrorAlert error="This is a simple error message" />

<!-- With title -->
<ErrorAlert 
  title="Operation Failed" 
  error="Unable to process your request due to a system error." 
/>

<!-- With Error object -->
<ErrorAlert error={new Error("Something went wrong")} />

<!-- With GraphQL errors -->
<ErrorAlert 
  title="GraphQL Errors" 
  error={{
    graphQLErrors: [
      { message: "Field 'user' is not defined" },
      { message: "Network timeout occurred" }
    ]
  }}
/>
```

For detailed examples and API documentation, visit the [ErrorAlert component page](/components/errorAlert).

### Checkboxes

Checkboxes allow users to select one or more items from a set, or to toggle a single option on/off.
They follow accessibility best practices and adapt to the design system's theme.

<div class="checkbox-examples">
  <div class="checkbox-row">
    <Checkbox id="checkbox-example-1" />
    <label for="checkbox-example-1">Unchecked checkbox</label>
  </div>
  
  <div class="checkbox-row">
    <Checkbox id="checkbox-example-2" checked />
    <label for="checkbox-example-2">Checked checkbox</label>
  </div>
  
  <div class="checkbox-row">
    <Checkbox id="checkbox-example-3" disabled />
    <label for="checkbox-example-3">Disabled checkbox</label>
  </div>
  
  <div class="checkbox-row">
    <Checkbox id="checkbox-example-4" disabled checked />
    <label for="checkbox-example-4">Disabled checked checkbox</label>
  </div>
</div>

The Checkbox component accepts all standard HTML input attributes:

```svelte
<script>
  import { Checkbox } from '$lib'
</script>

<!-- Basic usage -->
<Checkbox id="my-checkbox" />
<label for="my-checkbox">Click me</label>

<!-- Controlled state -->
<Checkbox checked={isChecked} on:change={handleChange} />

<!-- Disabled state -->
<Checkbox disabled />
<Checkbox disabled checked />

<!-- With form attributes -->
<Checkbox name="terms" value="agree" required />
```

Checkboxes can be used within forms to collect user input, or as standalone interactive elements for toggling options. Pair them with labels for better accessibility and user experience.

For detailed examples and API documentation, visit the [Checkbox component page](/components/checkbox).

### Loading Spinner

Loading spinners are used to indicate that content is being loaded or a process is running. They help provide visual feedback to users during asynchronous operations.

<div style="display: flex; align-items: center; gap: 2rem; margin-bottom: 1rem;">
  <div style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem;">
    <div style="height: 50px; width: 50px;">
      <LoadingSpinner />
    </div>
    <span>Default</span>
  </div>
  
  <div style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem;">
    <div style="height: 50px; width: 50px;">
      <LoadingSpinner style="--size: 2rem;" />
    </div>
    <span>Large</span>
  </div>
  
  <div>
    <span>Inline: </span>
    <LoadingSpinner inline />
    <span> loading...</span>
  </div>
</div>

The LoadingSpinner component is simple to use and can be customized to fit different contexts:

```svelte
<script>
  import { LoadingSpinner } from '$lib'
</script>

<!-- Default centered spinner -->
<LoadingSpinner />

<!-- Inline spinner for text content -->
<span>Loading data <LoadingSpinner inline /> please wait</span>

<!-- Custom sized spinner -->
<LoadingSpinner style="--size: 2rem;" />

<!-- Without automatic centering -->
<LoadingSpinner center={false} />
```

The spinner automatically adapts to the current theme and can be customized using CSS variables.

For detailed examples and API documentation, visit the [LoadingSpinner component page](/components/loadingSpinner).

## Data fetching
### GraphQL

The web app makes use of query composition, i.e. components define their own
data dependencies via fragments, which get composed by their callers and are
eventually being used in a query in a loader.

The goal of this approach is to make data dependencies co-located and easier
to change, as well as to make the flow of data clearer. Data fetching should only
happen in data loaders, not components.

There are a couple of issues to consider with this approach and sometimes we'll
have to make exceptions:

- Caching: If every loader composes its own query it's possible that two
  queries fetch the same data, in which case we miss out on caching. If caching
  the data is more important than data co-location it might be preferable to
  define a reusable query function. Example: File list for currently opened
  folder (sidebar + folder page)
- Shared data from layout loaders: While it's very convenient that pages have
  access to any data from the ancestor layout loaders, that doesn't work well
  with data dependency co-location. The layout loaders don't know which
  sub-layout or sub-page is loaded and what data it needs.
  Fortunately we don't have a lot of data (yet) that is used this way. The
  prime example for this right now is information about the authenticated user.
  The current approach is to name data-dependencies on the current user as
  `<ComponentName>_AuthenticatedUser` and use that fragment in the
  `AuthenticatedUser` fragment in `src/routes/layout.gql`.
  This approach might change as we uncover more use cases.
- On demand data loading: Not all data is fetched/needed immediately for
  rendering page. Data for e.g. typeaheads is fetched on demand. Ideally the
  related queries are still composed by the data loader, which passes a
  function for fetching the data to the page.

## Rolling out pages to production

For a page to be accessible in production, the server needs to know to serve the
SvelteKit for that page. Due to file based routing we can easily determine available
pages during build time. The list of available pages is generated by the `sg generate`
command, which in turn runs `bazel run //client/web-sveltekit:write_generated`.

To enable a page in production by default, add the following comment to the `+page.svelte`
file:

```svelte
<script lang="ts">
  // @sg EnableRollout
  // ...
</script>
```

and run `sg generate` or `bazel run //client/web-sveltekit:write_generated` to update the
list of available pages.

It's common now to create new pages in the new web app only, in which case the `//@sg EnableAlways`
flag needs to be set.