---
    layout: article
    title: Data fetching
---

## GraphQL

The web app makes use of query composition, i.e. components define their own
data dependencies via fragments, which get composed by their callers and are
eventually being used in a query in a loader.

The goal of this approach is to make data dependencies co-located and easier
to change, as well as to make the flow of data clearer. Data fetching should only
happen in data loaders, not components.

There are a couple of issues to consider with this approach and sometimes we'll
have to make exceptions:

- Caching: If every loader composes its own query it's possible that two
  queries fetch the same data, in which case we miss out on caching. If caching
  the data is more important than data co-location it might be preferable to
  define a reusable query function. Example: File list for currently opened
  folder (sidebar + folder page)
- Shared data from layout loaders: While it's very convenient that pages have
  access to any data from the ancestor layout loaders, that doesn't work well
  with data dependency co-location. The layout loaders don't know which
  sub-layout or sub-page is loaded and what data it needs.
  Fortunately we don't have a lot of data (yet) that is used this way. The
  prime example for this right now is information about the authenticated user.
  The current approach is to name data-dependencies on the current user as
  `<ComponentName>_AuthenticatedUser` and use that fragment in the
  `AuthenticatedUser` fragment in `src/routes/layout.gql`.
  This approach might change as we uncover more use cases.
- On demand data loading: Not all data is fetched/needed immediately for
  rendering page. Data for e.g. typeaheads is fetched on demand. Ideally the
  related queries are still composed by the data loader, which passes a
  function for fetching the data to the page.

## Rolling out pages to production

For a page to be accessible in production, the server needs to know to serve the
SvelteKit for that page. Due to file based routing we can easily determine available
pages during build time. The list of available pages is generated by the `sg generate`
command, which in turn runs `bazel run //client/web-sveltekit:write_generated`.

To enable a page in production by default, add the following comment to the `+page.svelte`
file:

```svelte
<script lang="ts">
  // @sg EnableRollout
  // ...

  let items = $derived(page.data.items)
</script>
```

and run `sg generate` or `bazel run //client/web-sveltekit:write_generated` to update the
list of available pages.

It's common now to create new pages in the new web app only, in which case the `//@sg EnableAlways`
flag needs to be set.
